exp = rexp,
rnorm)
dist(input$n)
})
# Generate a plot of the data ----
# Also uses the inputs to build the plot label. Note that the
# dependencies on the inputs and the data reactive expression are
# both tracked, and all expressions are called in the sequence
# implied by the dependency graph.
output$plot <- renderPlot({
dist <- input$dist
n <- input$n
hist(d(),
main = paste("r", dist, "(", n, ")", sep = ""),
col = "#75AADB", border = "white")
})
# Generate a summary of the data ----
output$summary <- renderPrint({
data <- d()
stats <- StatsR::get_descriptive_statistics(data, c("Minimum", "Q1", "Median", "Mean", "Q3", "Maximum"))
stats <- as.data.frame(stats)
stats <- format(stats, scientific = FALSE, digits=4)
stats.table.df <- data.frame(stats)
names(stats.table.df)[1] <- "StatsR"
stats
#data
})
# Generate an HTML table view of the data ----
output$table <- renderTable({
d()
})
}
# Create Shiny app ----
shinyApp(ui, server)
source("D:/Development/Projects/C++/SoftwareInteroperabilityExs/StatsR/tests/testthat.R")
source("D:/Development/Projects/C++/SoftwareInteroperability/StatsR/tests/testthat.R")
shiny::runApp()
library(zoo)                                       # Load zoo
library(StatsR)                                    # Native C++ stats library
library(Rcpp)
set.seed(98234)                                    # Creating example series
moving_average <- function(x, n = 5) {             # Create user-defined function
stats::filter(x, rep(1 / n, n), sides = 1)
}
n = 100                                            # n samples
observations <- 1:n + rnorm(n = n, mean = 0, sd = 10)
dates <- c(1:n)
my_moving_average_1 <- StatsR::get_moving_average(dates, observations, 5)
my_moving_average_1
my_moving_average_2 <- moving_average(observations, 5)   # Apply user-defined function
my_moving_average_2
tolerance = 1e-5
equal <- (my_moving_average_1 - my_moving_average_2) >= (tolerance - 0.5)
length(equal[TRUE])
my_moving_average_3 <- rollmean(observations, k = 5)  # Apply rollmean function
my_moving_average_3
plot(1:length(observations), observations, type = "l",   # Plotting series & moving metrics
ylim = c(min(observations), max(observations)),
xlab = "Time Series", ylab = "Values")
lines(1:length(observations), my_moving_average_1, type = "l", col = 2)
legend("topleft", c("Time Series", "Moving Average"), lty = 1, col = 1:5)
moduleTS <- Module("TS", PACKAGE="StatsR")
ts <- new(moduleTS$TimeSeries, dates, observations)
my_moving_average_4 <- ts$MovingAverage(5)
my_moving_average_4
equal <- (my_moving_average_4 - my_moving_average_2) >= (tolerance - 0.5)
length(equal[TRUE])
# No sample data
StatsR::t_test_summary_data(5, 9.261460, 0.2278881e-01, 195)
#
# One-sample t-test
#
data <- read.table("../data/weight.txt")
weight = data$V1
t.test(weight, mu = 25)
StatsR::t_test_one_sample(25, weight)
#
# Two-sample t-test
#
us_mpg <- read.table("../data/us-mpg.txt")
jp_mpg <- read.table("../data/jp-mpg.txt")
us = us_mpg$V1
jp = jp_mpg$V1
StatsR::t_test_two_sample(us, jp)
# No sample data
StatsR::z_test_summary_data(5, 6.7, 7.1, 29)
# One-sample data
StatsR::z_test_one_sample(3, c(3, 7, 11, 0, 7, 0, 4, 5, 6, 2))
# Two-sample data
x <- c( 7.8, 6.6, 6.5, 7.4, 7.3, 7.0, 6.4, 7.1, 6.7, 7.6, 6.8 )
y <- c( 4.5, 5.4, 6.1, 6.1, 5.4, 5.0, 4.1, 5.5 )
StatsR::z_test_two_sample(x, y)
library(Rcpp)
require(Rcpp)
library(formattable)
moduleStatsTests <- Module("StatsTests", PACKAGE="StatsR")
ttest0 <- new(moduleStatsTests$TTest, 5, 9.261460, 0.2278881e-01, 195)
if(ttest0$Perform()) {
results <- ttest0$Results()
print(results)
results <- as.data.frame(results)
formattable(results)
} else {
print("T-test from summary data failed.")
}
ttest1 <- new(moduleStatsTests$TTest, 25, weight)
if(ttest1$Perform()) {
print(ttest1$Results())
} else {
print("One-sample t-test failed.")
}
cols <- list('x1'=us, 'x2'=jp)
ttest2 <- new(moduleStatsTests$TTest, cols)
if(ttest2$Perform()) {
print(ttest2$Results())
} else {
print("Two-sample t-test failed.")
}
library(Rcpp)
library(formattable)
moduleStatsTests <- Module("StatsTests", PACKAGE="StatsR")
ztest0 <- new(moduleStatsTests$ZTest, 5, 6.7, 7.1, 29)
if(ztest0$Perform()) {
results <- ztest0$Results()
print(results)
results <- as.data.frame(results)
formattable(results)
} else {
print("Z-test from summary data failed.")
}
ztest1 <- new(moduleStatsTests$ZTest, 3, c(3, 7, 11, 0, 7, 0, 4, 5, 6, 2))
if(ztest1$Perform()) {
print(ztest1$Results())
} else {
print("One-sample z-test failed.")
}
cols <- list('x1'=x, 'x2'=y)
ztest2 <- new(moduleStatsTests$ZTest, cols)
if(ztest2$Perform()) {
print(ztest2$Results())
} else {
print("Two-sample z-test failed.")
}
library(tidyverse)
library(tsibble)
library(lubridate)
library(ggplot2)
library(ggpubr)
library(plotly)
library(dplyr)
library(formattable)                             # https://rfortherestofus.com/2019/11/how-to-make-beautiful-tables-in-r/
library(summarytools)
library(moments)                                 # Kurtosis
library(StatsR)                                  # Native C++ stats library
n = 1000                                         # n samples
data <- rnorm(n = n, mean = 0, sd = 1)           # from a Normal distribution with mean = 0, sd = 1
#write(data, ncolumns= 1, sep="\n", "data.txt")
obs <- c(1:n)
data.df <- data.frame(obs, data)                 # create a data frame
colnames(data.df) <- c("Index", "Value")
# Plot the data
ggplotly(
data.df %>%
ggplot(aes(x = obs, y = data)) +
geom_point(color = "steelblue") +
geom_line(color = "steelblue") +
# geom_smooth() +
labs(x = "Index", y = "Data", title = "Random Series") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
)
rownames <- c("Count", "Maximum", "Minimum", "Range",
"Kurtosis", "Median", "Mean", "StdDev.S",
"Sum", "StdErr", "Variance.S", "Skew")
stats <- StatsR::get_descriptive_statistics(data, rownames)
stats
stats <- as.data.frame(stats)
# Add equivalent values from R
baseR <- c(skewness(data),
var(data),
sqrt(var(data)/length(data)),
sum(data),
mean(data),
max(data),
n,
sd(data),
min(data),
max(data)-min(data),
kurtosis(data),
median(data)
)
tolerance = 1e-5
values <- stats[[1]]
equal <- (values - baseR) >= (tolerance - 0.5)
# Reformat the columns
stats <- format(stats, scientific = FALSE, digits=4)
baseR <- format(baseR, scientific = FALSE, digits=4)
stats.table.df <- data.frame(stats, baseR, equal)      # Create a data frame
names(stats.table.df)[1] <- "StatsR"                   # Rename the columns
names(stats.table.df)[2] <- "BaseR"
names(stats.table.df)[3] <- "Equal"
formattable(stats.table.df,
list(StatsR = formatter("span", style = ~formattable::style(color = ifelse(Equal == TRUE, "green", "red"))),
BaseR = formatter("span", style = ~formattable::style(color = ifelse(Equal == TRUE, "green", "red"))),
Equal = formatter("span", style = ~formattable::style(color = ifelse(Equal == TRUE, "green", "red")))
)
)                            # Display results
library(tidyverse)
library(tsibble)
library(lubridate)
library(ggplot2)
library(ggpubr)
library(plotly)
library(dplyr)
library(formattable)                             # https://rfortherestofus.com/2019/11/how-to-make-beautiful-tables-in-r/
library(summarytools)
library(moments)                                 # Kurtosis
library(StatsR)                                  # Native C++ stats library
n = 1000                                         # n samples
data <- rnorm(n = n, mean = 0, sd = 1)           # from a Normal distribution with mean = 0, sd = 1
#write(data, ncolumns= 1, sep="\n", "data.txt")
obs <- c(1:n)
data.df <- data.frame(obs, data)                 # create a data frame
colnames(data.df) <- c("Index", "Value")
# Plot the data
ggplotly(
data.df %>%
ggplot(aes(x = obs, y = data)) +
geom_point(color = "steelblue") +
geom_line(color = "steelblue") +
# geom_smooth() +
labs(x = "Index", y = "Data", title = "Random Series") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
)
rownames <- c("Count", "Maximum", "Minimum", "Range",
"Kurtosis", "Median", "Mean", "StdDev.S",
"Sum", "StdErr", "Variance.S", "Skew")
stats <- StatsR::get_descriptive_statistics(data, rownames)
stats
stats <- as.data.frame(stats)
# Add equivalent values from R
baseR <- c(skewness(data),
sum(data),
sd(data),
kurtosis(data),
max(data)-min(data),
var(data),
sqrt(var(data)/length(data)),
median(data),
min(data),
mean(data),
max(data),
n
)
tolerance = 1e-5
values <- stats[[1]]
equal <- (values - baseR) >= (tolerance - 0.5)
# Reformat the columns
stats <- format(stats, scientific = FALSE, digits=4)
baseR <- format(baseR, scientific = FALSE, digits=4)
stats.table.df <- data.frame(stats, baseR, equal)      # Create a data frame
names(stats.table.df)[1] <- "StatsR"                   # Rename the columns
names(stats.table.df)[2] <- "BaseR"
names(stats.table.df)[3] <- "Equal"
formattable(stats.table.df,
list(StatsR = formatter("span", style = ~formattable::style(color = ifelse(Equal == TRUE, "green", "red"))),
BaseR = formatter("span", style = ~formattable::style(color = ifelse(Equal == TRUE, "green", "red"))),
Equal = formatter("span", style = ~formattable::style(color = ifelse(Equal == TRUE, "green", "red")))
)
)                            # Display results
source("D:/Development/Projects/C++/SoftwareInteroperability/StatsR/tests/testthat.R")
library(tidyverse)
library(tsibble)
library(lubridate)
library(ggplot2)
library(ggpubr)
library(plotly)
library(dplyr)
library(formattable)                             # https://rfortherestofus.com/2019/11/how-to-make-beautiful-tables-in-r/
library(summarytools)
library(moments)                                 # Kurtosis
library(StatsR)                                  # Native C++ stats library
n = 1000                                         # n samples
data <- rnorm(n = n, mean = 0, sd = 1)           # from a Normal distribution with mean = 0, sd = 1
data <- rnorm(n = n, mean = 0, sd = 1)           # from a Normal distribution with mean = 0, sd = 1
#write(data, ncolumns= 1, sep="\n", "data.txt")
obs <- c(1:n)
data.df <- data.frame(obs, data)                 # create a data frame
View(data.df)
colnames(data.df) <- c("Index", "Value")
# Plot the data
ggplotly(
data.df %>%
ggplot(aes(x = obs, y = data)) +
geom_point(color = "steelblue") +
geom_line(color = "steelblue") +
# geom_smooth() +
labs(x = "Index", y = "Data", title = "Random Series") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
)
rownames <- c("Count", "Maximum", "Minimum", "Range",
"Kurtosis", "Median", "Mean", "StdDev.S",
"Sum", "StdErr", "Variance.S", "Skew")
stats <- StatsR::get_descriptive_statistics(data, rownames)
stats
stats <- as.data.frame(stats)
# Add equivalent values from R
baseR <- c(skewness(data),
sum(data),
sd(data),
kurtosis(data),
max(data)-min(data),
var(data),
sqrt(var(data)/length(data)),
median(data),
min(data),
mean(data),
max(data),
n
)
tolerance = 1e-5
values <- stats[[1]]
equal <- (values - baseR) >= (tolerance - 0.5)
# Reformat the columns
stats <- format(stats, scientific = FALSE, digits=4)
baseR <- format(baseR, scientific = FALSE, digits=4)
stats.table.df <- data.frame(stats, baseR, equal)      # Create a data frame
names(stats.table.df)[1] <- "StatsR"                   # Rename the columns
names(stats.table.df)[2] <- "BaseR"
names(stats.table.df)[3] <- "Equal"
formattable(stats.table.df,
list(StatsR = formatter("span", style = ~formattable::style(color = ifelse(Equal == TRUE, "green", "red"))),
BaseR = formatter("span", style = ~formattable::style(color = ifelse(Equal == TRUE, "green", "red"))),
Equal = formatter("span", style = ~formattable::style(color = ifelse(Equal == TRUE, "green", "red")))
)
)                            # Display results
library(stats)
library(tidyverse)
library(tsibble)
library(lubridate)
library(ggplot2)
library(ggpubr)
library(plotly)
library(dplyr)
library(formattable)                             # https://rfortherestofus.com/2019/11/how-to-make-beautiful-tables-in-r/
library(summarytools)
library(moments)                                 # Kurtosis
library(StatsR)                                  # Native C++ stats library
library(tidyverse)
library(tsibble)
library(lubridate)
library(ggplot2)
library(ggpubr)
library(plotly)
library(dplyr)
library(formattable)                             # https://rfortherestofus.com/2019/11/how-to-make-beautiful-tables-in-r/
library(summarytools)
library(moments)                                 # Kurtosis
library(StatsR)                                  # Native C++ stats library
library(StatsR)                                  # Native C++ stats library
n = 1000                                         # n samples
data <- rnorm(n = n, mean = 0, sd = 1)           # from a Normal distribution with mean = 0, sd = 1
#write(data, ncolumns= 1, sep="\n", "data.txt")
obs <- c(1:n)
data.df <- data.frame(obs, data)                 # create a data frame
colnames(data.df) <- c("Index", "Value")
# Plot the data
ggplotly(
data.df %>%
ggplot(aes(x = obs, y = data)) +
geom_point(color = "steelblue") +
geom_line(color = "steelblue") +
# geom_smooth() +
labs(x = "Index", y = "Data", title = "Random Series") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
)
rownames <- c("Count", "Maximum", "Minimum", "Range",
"Kurtosis", "Median", "Mean", "StdDev.S",
"Sum", "StdErr", "Variance.S", "Skew")
stats <- StatsR::get_descriptive_statistics(data, rownames)
stats
stats <- as.data.frame(stats)
# Add equivalent values from R
baseR <- c(skewness(data),
sum(data),
sd(data),
kurtosis(data),
max(data)-min(data),
var(data),
sqrt(var(data)/length(data)),
median(data),
min(data),
mean(data),
max(data),
n
)
tolerance = 1e-5
values <- stats[[1]]
equal <- (values - baseR) >= (tolerance - 0.5)
# Reformat the columns
stats <- format(stats, scientific = FALSE, digits=4)
baseR <- format(baseR, scientific = FALSE, digits=4)
stats.table.df <- data.frame(stats, baseR, equal)      # Create a data frame
names(stats.table.df)[1] <- "StatsR"                   # Rename the columns
names(stats.table.df)[2] <- "BaseR"
names(stats.table.df)[3] <- "Equal"
formattable(stats.table.df,
list(StatsR = formatter("span", style = ~formattable::style(color = ifelse(Equal == TRUE, "green", "red"))),
BaseR = formatter("span", style = ~formattable::style(color = ifelse(Equal == TRUE, "green", "red"))),
Equal = formatter("span", style = ~formattable::style(color = ifelse(Equal == TRUE, "green", "red")))
)
)                            # Display results
predict <- function(b0, b1, x){
return (b0 + b1 * x)
}
data <- read.table(file.path(getwd(),'../data/HouseData.csv'), header=TRUE, sep=",", fileEncoding = "UTF-8-BOM")
ggplot(data, aes(x=Size, y=Price)) +
geom_point()+
geom_smooth(method=lm, se=FALSE)
results <- StatsR::linear_regression(data$Size, data$Price)
results
b0 <- results["b0"]
b1 <- results["b1"]
size = 2.5
predicted_price <- predict(b0, b1, size);
sprintf("Predicted price for size: %.2f sq ft= %.2fk", size * 1000, predicted_price * 100)
fm <- lm(Price ~ Size, data=data)
summary(fm)                                      # Fit a simple linear regression and look at the analysis.
# No sample data
StatsR::t_test_summary_data(5, 9.261460, 0.2278881e-01, 195)
#
# One-sample t-test
#
data <- read.table("../data/weight.txt")
weight = data$V1
t.test(weight, mu = 25)
StatsR::t_test_one_sample(25, weight)
#
# Two-sample t-test
#
us_mpg <- read.table("../data/us-mpg.txt")
jp_mpg <- read.table("../data/jp-mpg.txt")
us = us_mpg$V1
jp = jp_mpg$V1
StatsR::t_test_two_sample(us, jp)
# No sample data
StatsR::z_test_summary_data(5, 6.7, 7.1, 29)
# One-sample data
StatsR::z_test_one_sample(3, c(3, 7, 11, 0, 7, 0, 4, 5, 6, 2))
# Two-sample data
x <- c( 7.8, 6.6, 6.5, 7.4, 7.3, 7.0, 6.4, 7.1, 6.7, 7.6, 6.8 )
y <- c( 4.5, 5.4, 6.1, 6.1, 5.4, 5.0, 4.1, 5.5 )
StatsR::z_test_two_sample(x, y)
library(Rcpp)
require(Rcpp)
library(formattable)
moduleStatsTests <- Module("StatsTests", PACKAGE="StatsR")
ttest0 <- new(moduleStatsTests$TTest, 5, 9.261460, 0.2278881e-01, 195)
if(ttest0$Perform()) {
results <- ttest0$Results()
print(results)
results <- as.data.frame(results)
formattable(results)
} else {
print("T-test from summary data failed.")
}
ttest1 <- new(moduleStatsTests$TTest, 25, weight)
if(ttest1$Perform()) {
print(ttest1$Results())
} else {
print("One-sample t-test failed.")
}
cols <- list('x1'=us, 'x2'=jp)
ttest2 <- new(moduleStatsTests$TTest, cols)
if(ttest2$Perform()) {
print(ttest2$Results())
} else {
print("Two-sample t-test failed.")
}
library(Rcpp)
library(formattable)
moduleStatsTests <- Module("StatsTests", PACKAGE="StatsR")
ztest0 <- new(moduleStatsTests$ZTest, 5, 6.7, 7.1, 29)
if(ztest0$Perform()) {
results <- ztest0$Results()
print(results)
results <- as.data.frame(results)
formattable(results)
} else {
print("Z-test from summary data failed.")
}
ztest1 <- new(moduleStatsTests$ZTest, 3, c(3, 7, 11, 0, 7, 0, 4, 5, 6, 2))
if(ztest1$Perform()) {
print(ztest1$Results())
} else {
print("One-sample z-test failed.")
}
cols <- list('x1'=x, 'x2'=y)
ztest2 <- new(moduleStatsTests$ZTest, cols)
if(ztest2$Perform()) {
print(ztest2$Results())
} else {
print("Two-sample z-test failed.")
}
install.packages("caret")
install.packages("factoextra")
install.packages("tidymodels")
install.packages("tidyquant")
install.packages("modeltime")
install.packages("timetk")
install.packages("glmnet")
install.packages("workflowsets")
install.packages("ragg")
